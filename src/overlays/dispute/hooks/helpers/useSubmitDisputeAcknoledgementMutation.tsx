import { useMutation, useQueryClient } from '@tanstack/react-query'
import { Keyboard } from 'react-native'
import { useOverlayContext } from '../../../../contexts/overlay'
import { useShowErrorBanner } from '../../../../hooks/useShowErrorBanner'
import { account } from '../../../../utils/account'
import { getChat, saveChat } from '../../../../utils/chat'
import { initDisputeSystemMessages } from '../../../../utils/chat/initDisputeSystemMessages'
import { saveContract } from '../../../../utils/contract'
import { isEmailRequiredForDispute } from '../../../../utils/dispute'
import { acknowledgeDispute } from '../../../../utils/peachAPI/private/contract'

const acknowledgeDisputeMutation = async (contractId: string, email?: string) => {
  const [result, err] = await acknowledgeDispute({
    contractId,
    email,
  })
  if (result) {
    return result
  } else if (err) {
    throw new Error(err.error)
  }
  throw new Error('UNKNOWN_ERROR')
}

export const useSubmitDisputeAcknoledgementMutation = () => {
  const [, updateOverlay] = useOverlayContext()
  const queryClient = useQueryClient()
  const showError = useShowErrorBanner()

  return useMutation({
    onMutate: async ({ contractId }) => {
      await queryClient.cancelQueries({ queryKey: ['contract', contractId] })
      const previousContract = queryClient.getQueryData<Contract>(['contract', contractId])
      queryClient.setQueryData(
        ['contract', contractId],
        (oldQueryData: Contract | undefined) =>
          oldQueryData && {
            ...oldQueryData,
            disputeDate: new Date(Date.now()),
            disputeInitiator:
              oldQueryData.seller.id === account.publicKey ? oldQueryData.buyer.id : oldQueryData.seller.id,
            disputeAcknowledgedByCounterParty: true,
            isEmailRequired: false,
          },
      )
      return { previousContract }
    },
    mutationFn: ({ email, contractId }: { email?: string; disputeReason: DisputeReason; contractId: string }) =>
      acknowledgeDisputeMutation(contractId, email),
    onError: (err: Error, { contractId }, context) => {
      showError(err.message)
      queryClient.setQueryData(['contract', contractId], context?.previousContract)
    },
    onSuccess: async (_data, { disputeReason, contractId }) => {
      const updatedContract = queryClient.getQueryData<Contract>(['contract', contractId])
      if (!updatedContract) return
      saveContract(updatedContract)
      const chat = getChat(contractId)
      const autogeneratedMessages = initDisputeSystemMessages(chat.id, updatedContract)
      saveChat(contractId, {
        messages: autogeneratedMessages,
      })
      if (isEmailRequiredForDispute(disputeReason)) {
        Keyboard.dismiss()
      }
    },
    onSettled: (_data, _error, { contractId }) => {
      updateOverlay({ visible: false })
      queryClient.invalidateQueries(['contract', contractId])
    },
  })
}
