import { useMutation, useQueryClient } from '@tanstack/react-query'
import { Keyboard } from 'react-native'
import { useOverlayContext } from '../../../../contexts/overlay'
import { useShowErrorBanner } from '../../../../hooks/useShowErrorBanner'
import { useShowLoadingOverlay } from '../../../../hooks/useShowLoadingOverlay'
import { account } from '../../../../utils/account'
import { getChat, saveChat } from '../../../../utils/chat'
import { initDisputeSystemMessages } from '../../../../utils/chat/initDisputeSystemMessages'
import { saveContract } from '../../../../utils/contract'
import { isEmailRequiredForDispute } from '../../../../utils/dispute'
import i18n from '../../../../utils/i18n'
import { acknowledgeDispute } from '../../../../utils/peachAPI/private/contract'
import { isEmail } from '../../../../utils/validation'

const acknowledgeDisputeMutation = async (contractId: string, email: string, disputeReason: DisputeReason) => {
  if (isEmailRequiredForDispute(disputeReason) && !isEmail(email)) {
    throw new Error('INVALID_EMAIL')
  }
  const [result, err] = await acknowledgeDispute({
    contractId,
    email,
  })
  if (result) {
    return result
  } else if (err) {
    throw new Error(err.error)
  }
  throw new Error('UNKNOWN_ERROR')
}

export const useSubmitDisputeAcknowledgement = () => {
  const [, updateOverlay] = useOverlayContext()
  const queryClient = useQueryClient()
  const showError = useShowErrorBanner()
  const showLoadingOverlay = useShowLoadingOverlay()
  const { mutate: submitDisputeAcknowledgement } = useMutation({
    onMutate: async ({ contractId, disputeReason, email }) => {
      await queryClient.cancelQueries({ queryKey: ['contract', contractId] })
      const previousContract = queryClient.getQueryData<Contract>(['contract', contractId])
      if (isEmailRequiredForDispute(disputeReason) && !isEmail(email)) return { previousContract }
      showLoadingOverlay({
        title: i18n('dispute.opened'),
        level: 'WARN',
      })
      queryClient.setQueryData(
        ['contract', contractId],
        (oldQueryData: Contract | undefined) =>
          oldQueryData && {
            ...oldQueryData,
            disputeDate: new Date(Date.now()),
            disputeInitiator:
              oldQueryData.seller.id === account.publicKey ? oldQueryData.buyer.id : oldQueryData.seller.id,
            disputeAcknowledgedByCounterParty: true,
            isEmailRequired: false,
          },
      )
      return { previousContract }
    },
    mutationFn: ({
      contractId,
      email,
      disputeReason,
    }: {
      email: string
      disputeReason: DisputeReason
      contractId: string
    }) => acknowledgeDisputeMutation(contractId, email, disputeReason),
    onError: (err: Error, { contractId }, context) => {
      showError(err.message)
      queryClient.setQueryData(['contract', contractId], context?.previousContract)
    },
    onSuccess: async (_data, { disputeReason, contractId }) => {
      const updatedContract = queryClient.getQueryData<Contract>(['contract', contractId])
      if (!updatedContract) return
      saveContract(updatedContract)
      const chat = getChat(contractId)
      const autogeneratedMessages = initDisputeSystemMessages(chat.id, updatedContract)
      saveChat(contractId, {
        messages: autogeneratedMessages,
      })
      if (isEmailRequiredForDispute(disputeReason)) {
        Keyboard.dismiss()
      }
    },
    onSettled: (_data, _error, { contractId }) => {
      updateOverlay({ visible: false })
      queryClient.invalidateQueries(['contract', contractId])
    },
  })

  return submitDisputeAcknowledgement
}
